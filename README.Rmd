---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  message = FALSE,
  warning = FALSE
)
```

# sostools

<!-- badges: start -->
<!-- badges: end -->

This is just a collection of functions I use in my research that I use
frequently. Other functions I use infrequently can be found in my `snippets`
repo.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("tsostarics/sostools")
```
## Easily reference coefficients in prose

Here is a simple example of referencing the values of a model summary
without needing to hand write or format it yourself. See `?get_coef` for more
information. `make_coef_getter` is a function factory that provides a shorthand
if you have multiple models you're working with.

```{r example}
library(sostools)
library(tidyverse)
mdl <- lm(mpg ~ cyl * gear, data = mtcars) # Create model
coefs <- enlist_coefs(mdl) # Create coefficients
get_coef1 <- make_coef_getter(mdl) # Using the model object directly
get_coef2 <- make_coef_getter(coefs) # Using the list of coefficients we made
get_coef("cyl:gear", coefs)
get_coef1("cyl:gear")
get_coef2("cyl:gear")
```

Here we can get the formatted values of a write up easily with in-line R code.
You could say something like: We found no significant effect of cylinder 
`r get_coef2("cyl")` or gear `r get_coef2("gear")` nor a significant interaction
between the two `r get_coef2("cyl:gear")`.

## Retain contrast coding labels
Here's a test data set with some factors that we might want to apply
particular contrasts to.
```{r}
mdl_data <- 
  mtcars %>% 
  as_tibble() %>% 
  mutate(cyl = factor(cyl), 
         twolevel = round(runif(n()),0),
         twolevel = ifelse(twolevel == 1, "a", "b"),
         twolevel = factor(twolevel))
contrasts(mdl_data$cyl) # 3 level treatment coding
contrasts(mdl_data$twolevel) # 2 level treatment coding
contrast_code(mdl_data$twolevel) # 2 level scaled sum coding
```

First, we can specify the contrast matrix manually using `contrast_code()`
or `manual_code()`. The former will invoke the latter if it detects a matrix.

```{r}
# You can specify contrast matrix manually
contrasts(mdl_data$cyl) <- contrast_code(mdl_data$cyl,
                                         matrix(c(2/3, -1/3, -1/3,
                                                  -1/3, -1/3, 2/3),
                                                nrow = 3))

# contrasts now updated with labels retained and proper comparison labels
# set depending on what the reference level is (here, 6 is the reference)
contrasts(mdl_data$cyl) 

# also works for polynomial coding
contrast_code(mdl_data$cyl, contr.poly(3))
```

Because manually specifying matrices is time consuming for some common contrast
schemes, you can also pass a function that generates contrasts to `contrast_code()` 
which will invoke `functional_code()`. A series of helpers are included in this
package, but they also work with R's built in `contr.___` functions. When
applicable with sum and dummy coding, you can pass in a desired reference level.
Coding schemes that require a specific level order, such as forward/backward
difference or helmert coding, should be set with `levels<-` **before** applying 
contrasts.
```{r}
contrast_code(mdl_data$cyl, scaled_sum_code)
contrast_code(mdl_data$cyl, scaled_sum_code, reference = "6")
contrast_code(mdl_data$cyl, forward_difference_code)
contrast_code(mdl_data$cyl, backward_difference_code)
contrast_code(mdl_data$cyl, helmert_code)
contrast_code(mdl_data$cyl, reverse_helmert_code)
contrast_code(mdl_data$cyl, contr.poly)
contrast_code(mdl_data$cyl, contr.sum)
contrast_code(mdl_data$cyl, contr.treatment)
contrast_code(mdl_data$cyl, contr.treatment, reference = "6")
```

### Using `contrasts` argument in modeling functions

Rather than manually setting the contrasts on the data frame itself, you can
also utilize the `contrasts` argument in functions like `lm`, which take a named
list of contrast matrices where the names correspond to factor predictors. This
package provides a function `enlist_contrasts` to take advantage of this. Make
sure your model fitting function supports this argument. 

```{r}
mdl_data <- mutate(mdl_data, gear = factor(gear), carb = factor(carb))

my_contrasts <- 
  enlist_contrasts(mdl_data,
                   cyl ~ contr.sum + 6, # Set the reference level with + ___
                   twolevel ~ scaled_sum_code + "a",
                   gear ~ forward_difference_code,
                   carb ~ helmert_code)

my_model <- lm(mpg ~ cyl + twolevel + gear + carb, 
               data = mdl_data,  
               contrasts = my_contrasts)

summary(my_model)
```

In the above code, the contrast functions used can also be matrices assigned to
a variable as in `my_var <- matrix(...); factor ~ my_var`. Reference levels set 
with `+ "a"` or `+ 6` can also be assigned to a variable beforehand, e.g. 
`ref_level <- 6; cyl ~ contr.sum + ref_level`. Note this means that 
`factor ~ scheme + a` and `factor ~ scheme + "a"` are *not* equivalent. The former
will throw an error if the object `a` is not found.

And we can always check what the contrasts are. Here I use `fractions` from the
`MASS` package to print the contrasts as fractions instead of decimals.

```{r}
lapply(my_contrasts, function(x) MASS::fractions(x))
```

This function also gives you a message if you have factor columns that you didn't
set the contrasts for.

```{r, message = TRUE}
enlist_contrasts(mdl_data, carb ~ contr.sum)
```

