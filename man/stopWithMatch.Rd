% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_trymatch.R
\name{stopWithMatch}
\alias{stopWithMatch}
\title{Augment error message}
\usage{
stopWithMatch(e, ..., exprstr = deparse1(sys.call(1)))
}
\arguments{
\item{e}{simpleError object}

\item{...}{Series of named character vectors}

\item{exprstr}{Default \code{deparse1(sys.call(1))}, a string of the expression
to be evaluated to print for debugging purposes.}
}
\value{
Nothing, throws an error with the matches. When using this, the
original calling function should be followed by a \code{stop()} call in case there
are no matches.
}
\description{
Match an error message to arbitrary possibilities
}
\details{
The names of \code{...} correspond to strings that should be matched against the
condition message from the error. If there's a match for any particular
message, then display the corresponding value as an (i) bullet.
If an element of \code{...} is a character vector with length > 1, then the first
element will show a (i) bullet and the subsequent elements will appear on
their own lines with an indent instead of an (i).

\code{stopWithmatch()} should be used instead of \code{tryMatch()} if you need to
also run additional code when handling the error. \code{tryMatch()} is a drop-in
replacement for \code{tryCatch()} iff all you need is to augment error messages.
See examples for more information.

\code{exprstr} will be truncated if it is longer than 64 characters so that it
fits on a line of 80 characters.
}
\examples{
try(contrastable:::tryMatch(a + 1,
                            "not found" = "there is no a object!",
                            "'a' not" = c("oh no!", "how sad!")))

foo <- function(a) {
tryCatch(a, error = \(e) {
  message("An error! have a random number: ", rnorm(1))
  contrastable:::stopWithMatch(e, "not found" = "how sad!")
 })
}

foo2 <- function(a) {
  contrastable:::tryMatch(a, "not found" = "how sad!")
}

try(foo(a + 1))
try(foo2(a + 1))
}
