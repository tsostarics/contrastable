% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_trymatch.R
\name{tryMatch}
\alias{tryMatch}
\title{Error handling with regex matching on condition message}
\usage{
tryMatch(expr, ..., .parent = TRUE)
}
\arguments{
\item{expr}{Expression to evaluate}

\item{...}{One or more named character vectors. Can be atomic, must be named.}

\item{.parent}{Logical, whether to show the parent call instead of the actual
call passed to tryMatch. Default TRUE.}
}
\value{
The value of \code{eval(expr)} if no error, otherwise thows a formatted
error
}
\description{
Evaluate an expression and, if it throws an error, attempts to match it
to one or more options provided to \code{...}..
}
\details{
The names of \code{...} correspond to strings that should be matched against the
condition message from the error. If there's a match for any particular
message, then display the corresponding value as an (i) bullet.
If an element of \code{...} is a character vector with length > 1, then the first
element will show a (i) bullet and the subsequent elements will appear on
their own lines with an indent instead of an (i).

\code{stopWithmatch()} should be used instead of \code{tryMatch()} if you need to
also run additional code when handling the error. \code{tryMatch()} is a drop-in
replacement for \code{tryCatch()} iff all you need is to augment error messages.
See examples for more information.

\code{exprstr} will be truncated if it is longer than 64 characters so that it
fits on a line of 80 characters.
}
\examples{
try(contrastable:::tryMatch(a + 1,
                            "not found" = "there is no a object!",
                            "'a' not" = c("oh no!", "how sad!")))

foo <- function(a) {
tryCatch(a, error = \(e) {
  set.seed(111)
  message("An error! have a random number: ", rnorm(1))
  contrastable:::stopWithMatch(e, "not found" = "how sad!")
 })
}

foo2 <- function(a) {
  contrastable:::tryMatch(a, "not found" = "how sad!")
}

try(foo(a + 1))
try(foo2(a + 1))
}
\keyword{internal}
